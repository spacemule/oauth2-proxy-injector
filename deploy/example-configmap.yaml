# Default oauth2-proxy ConfigMap
#
# This is the DEFAULT ConfigMap that the webhook uses for all pods.
# It should be deployed in the webhook's namespace (e.g., oauth2-proxy-system).
#
# Pods can:
# 1. Use this default by NOT specifying spacemule.net/oauth2-proxy.config annotation
# 2. Override with a different ConfigMap using: spacemule.net/oauth2-proxy.config: "other-config"
# 3. Override individual settings via annotations (see example pod below)
#
# Many of these settings can be overridden per-pod via annotations.
# See the example pod below for override annotations.
---
apiVersion: v1
kind: ConfigMap
metadata:
  # This name must match --default-config flag (defaults to "oauth2-proxy-config")
  name: oauth2-proxy-config
  # Deploy in the webhook's namespace (must match --config-namespace flag)
  namespace: oauth2-proxy-system
  labels:
    app.kubernetes.io/component: oauth2-proxy-config
data:
  # ===== Provider Settings (ConfigMap only - shared across namespace) =====

  # OAuth2 provider type
  # Options: oidc, google, github, azure, keycloak, etc.
  provider: "oidc"

  # OIDC issuer URL (required for provider=oidc)
  oidc-issuer-url: "https://auth.example.com/realms/myrealm"

  # OIDC groups claim - which claim contains group membership
  # Default: "groups" - override if your provider uses a different claim
  # oidc-groups-claim: "groups"

  # OAuth scopes to request
  # Default: "openid email profile" for OIDC
  # scope: "openid email profile groups"

  # ===== Identity Settings (overridable via annotations) =====

  # OAuth2 client ID
  client-id: "my-application"

  # Reference to Secret containing client secret
  # Format: "secret-name" or "secret-name:key"
  # Create secret with:
  # kubectl create secret generic oauth2-secrets \
  #   --from-literal=client-secret=your-client-secret \
  #   --from-literal=cookie-secret=$(openssl rand -base64 32 | head -c 32)
  client-secret-ref: "oauth2-secrets:client-secret"

  # Use PKCE flow (allows skipping client-secret-ref for public clients)
  # pkce-enabled: "true"

  # ===== Cookie Settings =====

  # Reference to Secret containing cookie encryption secret
  # Must be 16, 24, or 32 bytes for AES encryption
  cookie-secret-ref: "oauth2-secrets:cookie-secret"

  # Cookie domains (comma-separated, optional)
  # Leave empty for automatic detection
  # cookie-domains: ".example.com"

  # Require HTTPS for cookies (should be true in production!)
  cookie-secure: "true"

  # Cookie name (default: "_oauth2_proxy")
  # Useful to prevent cookie collision when multiple proxied services share a domain
  # cookie-name: "_oauth2_proxy_myapp"

  # ===== Authorization Settings (overridable via annotations) =====

  # Allowed email domains (comma-separated)
  # Use "*" to allow all domains
  email-domains: "example.com,corp.example.com"

  # Allowed groups (comma-separated, optional)
  # Only users in these groups can access
  # Works with providers that support group claims
  # allowed-groups: "developers,admins"

  # Domains allowed for post-auth redirects (security feature)
  # Prevents open redirect vulnerabilities
  # whitelist-domains: ".example.com,.corp.example.com"

  # ===== Routing Settings (overridable via annotations) =====

  # OAuth callback URL (usually needs to be different per-service)
  # Example: "https://myapp.example.com/oauth2/callback"
  # redirect-url: "https://myapp.example.com/oauth2/callback"

  # Extra JWT issuers for bearer token auth (comma-separated "issuer=audience" pairs)
  # Example: "https://issuer1.com=api,https://issuer2.com=api"
  # extra-jwt-issuers: "https://issuer1.com=api"

  # ===== Header/Token Passing Settings (overridable via annotations) =====

  # Pass OAuth access token to upstream via X-Forwarded-Access-Token
  # pass-access-token: "true"

  # Set X-Auth-Request-User, X-Auth-Request-Email headers
  # set-xauthrequest: "true"

  # Pass OIDC ID token via Authorization: Bearer header
  # pass-authorization-header: "true"

  # ===== Behavior Settings (overridable via annotations) =====

  # Skip the "Sign in with X" button page
  # Set to true to redirect directly to the provider
  skip-provider-button: "true"

  # ===== Container Settings (ConfigMap only - not overridable) =====

  # oauth2-proxy container image
  proxy-image: "quay.io/oauth2-proxy/oauth2-proxy:v7.5.1"

  # Extra arguments (newline-separated)
  # WARNING: Not overridable via annotations for security
  # extra-args: |
  #   --pass-user-headers=true
  #   --reverse-proxy=true

---
# Secret for oauth2-proxy credentials
# Deploy in the webhook's namespace alongside the default ConfigMap
# Create with actual secrets - don't commit real values!
# kubectl create secret generic oauth2-secrets -n oauth2-proxy-system \
#   --from-literal=client-secret=your-actual-client-secret \
#   --from-literal=cookie-secret=$(openssl rand -base64 32 | head -c 32)
apiVersion: v1
kind: Secret
metadata:
  name: oauth2-secrets
  namespace: oauth2-proxy-system  # Same namespace as the default ConfigMap
type: Opaque
stringData:
  client-secret: "REPLACE_WITH_REAL_CLIENT_SECRET"
  # Generate with: openssl rand -base64 32 | head -c 32
  cookie-secret: "REPLACE_WITH_32_BYTE_RANDOM_STRING"

---
# Example Pod using the oauth2-proxy injection
# This demonstrates ALL available annotations
apiVersion: v1
kind: Pod
metadata:
  name: example-protected-app
  namespace: default
  annotations:
    # ===== Core =====
    spacemule.net/oauth2-proxy.enabled: "true"
    # Optional: override the default ConfigMap (omit to use webhook's default)
    # spacemule.net/oauth2-proxy.config: "my-custom-config"

    # ===== Port/Routing (annotation-only) =====
    # Protected port - EITHER this OR upstream is required
    # Named port (e.g., "http"): Takes over the port from app container
    # Numbered port (e.g., "8080"): Service mode, use with Service webhook
    spacemule.net/oauth2-proxy.protected-port: "http"
    # Explicit upstream URL - alternative to protected-port
    # When set, oauth2-proxy uses this URL directly instead of auto-calculating
    # spacemule.net/oauth2-proxy.upstream: "http://127.0.0.1:8080"
    # Paths to skip authentication (comma-separated regex patterns)
    # Format: method=path_regex OR method!=path_regex. For all methods: path_regex
    spacemule.net/oauth2-proxy.ignore-paths: "/health,/metrics,GET=/ready"
    # Paths requiring JWT only, no login redirect (comma-separated)
    spacemule.net/oauth2-proxy.api-paths: "/api/,/v1/"
    # Skip login page when JWT bearer token is provided
    spacemule.net/oauth2-proxy.skip-jwt-bearer-tokens: "false"
    # Upstream TLS mode: "http" (default), "https", or "https-insecure"
    # Only affects auto-calculated upstream (ignored when upstream is set explicitly)
    spacemule.net/oauth2-proxy.upstream-tls: "http"

    # ===== Security (annotation-only) =====
    # Block direct access to protected port via iptables
    # Requires NET_ADMIN capability - ensure your PSP/PSA allows it
    # Health checks are automatically rewritten to go through oauth2-proxy
    # spacemule.net/oauth2-proxy.block-direct-access: "true"
    # Custom health check paths (if your app uses /ping or /ready)
    # spacemule.net/oauth2-proxy.ping-path: "/oauth2/ping"
    # spacemule.net/oauth2-proxy.ready-path: "/oauth2/ready"

    # ===== Identity Overrides (override ConfigMap values) =====
    # Different OAuth app for this service
    # spacemule.net/oauth2-proxy.client-id: "my-service-client"
    # spacemule.net/oauth2-proxy.client-secret-ref: "my-service-secrets:client-secret"
    # spacemule.net/oauth2-proxy.cookie-secret-ref: "my-service-secrets:cookie-secret"
    # spacemule.net/oauth2-proxy.scope: "openid email profile groups"
    # spacemule.net/oauth2-proxy.pkce-enabled: "true"

    # ===== Authorization Overrides (stricter than namespace default) =====
    # spacemule.net/oauth2-proxy.email-domains: "example.com"
    # spacemule.net/oauth2-proxy.allowed-groups: "admin,devops"
    # spacemule.net/oauth2-proxy.whitelist-domains: ".example.com"

    # ===== Cookie Overrides =====
    # spacemule.net/oauth2-proxy.cookie-name: "_oauth2_proxy_myservice"
    # spacemule.net/oauth2-proxy.cookie-domains: ".example.com"

    # ===== Routing Overrides =====
    # spacemule.net/oauth2-proxy.redirect-url: "https://myservice.example.com/oauth2/callback"
    # spacemule.net/oauth2-proxy.extra-jwt-issuers: "https://issuer.example.com=myservice-api"

    # ===== Header Overrides =====
    # spacemule.net/oauth2-proxy.pass-access-token: "true"
    # spacemule.net/oauth2-proxy.set-xauthrequest: "true"
    # spacemule.net/oauth2-proxy.pass-authorization-header: "true"

    # ===== Behavior Overrides =====
    # spacemule.net/oauth2-proxy.skip-provider-button: "true"
spec:
  containers:
    - name: app
      image: nginx:latest
      ports:
        - containerPort: 8080
          name: http  # This named port will be protected
        - containerPort: 9090
          name: metrics  # This port remains accessible directly

---
# =====================================================================
# Service Mutation Webhook
# =====================================================================
#
# For scenarios where you need to protect multiple ports or can't use
# named port takeover, the Service webhook can rewrite targetPort values
# to route traffic through oauth2-proxy.
#
# Use Cases:
# - Multi-port applications (e.g., MediaMTX with HLS + WebRTC)
# - Applications with numbered ports (no named ports)
# - Selective port protection (only some ports need auth)
#
# How It Works:
# 1. Pod gets oauth2-proxy sidecar injected (via Pod webhook)
# 2. Service webhook rewrites specified targetPort values to the proxy port
# 3. Traffic flows: Client -> Service -> oauth2-proxy -> App container
#
# =====================================================================

---
# Example Service using the oauth2-proxy Service mutation
apiVersion: v1
kind: Service
metadata:
  name: example-protected-service
  namespace: default
  annotations:
    # ===== Core =====
    # List of ports to route through oauth2-proxy (comma-separated)
    # Can be port names OR port numbers
    spacemule.net/oauth2-proxy.rewrite-ports: "http,hls"

    # Optional: override proxy port (default: 4180)
    # spacemule.net/oauth2-proxy.proxy-port: "4180"

    # ===== Argo CD Compatibility =====
    # The Service webhook mutates targetPort values, which causes Argo CD
    # to show the Service as out-of-sync and revert changes on sync.
    #
    # To prevent this, add the following to your Argo CD Application spec:
    #
    #   spec:
    #     ignoreDifferences:
    #     - group: ""
    #       kind: Service
    #       jqPathExpressions:
    #       - .spec.ports[].targetPort
    #     syncPolicy:
    #       syncOptions:
    #       - RespectIgnoreDifferences=true
    #
    # The RespectIgnoreDifferences option is REQUIRED - without it, Argo CD
    # will still overwrite the mutated targetPort values during sync.
spec:
  selector:
    app: example-protected-app
  ports:
    - name: http
      port: 80
      targetPort: http    # Webhook rewrites this to 4180
    - name: hls
      port: 8888
      targetPort: 8554    # Webhook rewrites this to 4180
    - name: metrics
      port: 9090
      targetPort: 9090    # NOT in rewrite-ports, stays unchanged

---
# =====================================================================
# MediaMTX Example (Multi-Port Application)
# =====================================================================
#
# MediaMTX has multiple ports:
# - 8554: RTSP
# - 8888: HLS streaming
# - 8889: WebRTC/API
# - 9998: Metrics
#
# In this example, we protect HLS (8888) with oauth2-proxy while leaving
# RTSP and metrics accessible directly.
# =====================================================================

---
# MediaMTX Pod with oauth2-proxy injection
apiVersion: v1
kind: Pod
metadata:
  name: mediamtx
  namespace: media
  annotations:
    spacemule.net/oauth2-proxy.enabled: "true"
    spacemule.net/oauth2-proxy.config: "media-oauth-config"
    # Option 1: Numbered port = service mode (app keeps its ports, no takeover)
    spacemule.net/oauth2-proxy.protected-port: "8888"
    # Option 2: Explicit upstream (alternative to protected-port)
    # spacemule.net/oauth2-proxy.upstream: "http://127.0.0.1:8888"
    # Skip auth for HLS segment requests (performance)
    spacemule.net/oauth2-proxy.ignore-paths: ".*\\.m3u8$,.*\\.ts$"
spec:
  containers:
    - name: mediamtx
      image: bluenviron/mediamtx:latest
      ports:
        - name: rtsp
          containerPort: 8554
        - name: hls
          containerPort: 8888
        - name: api
          containerPort: 8889
        - name: metrics
          containerPort: 9998

---
# MediaMTX Service with selective port protection
apiVersion: v1
kind: Service
metadata:
  name: mediamtx
  namespace: media
  annotations:
    # Only rewrite HLS port to go through oauth2-proxy
    spacemule.net/oauth2-proxy.rewrite-ports: "hls"
    # See "Argo CD Compatibility" note above for handling out-of-sync warnings
spec:
  selector:
    app: mediamtx
  ports:
    - name: rtsp
      port: 8554
      targetPort: 8554    # Direct to app (no auth needed for RTSP)
    - name: hls
      port: 8888
      targetPort: hls     # Webhook rewrites to 4180 (through oauth2-proxy)
    - name: api
      port: 8889
      targetPort: 8889    # Direct to app
    - name: metrics
      port: 9998
      targetPort: 9998    # Direct to app (metrics scraping)
